Даны два целочисленных массива nums1и nums2, вернуть массив их пересечения . Каждый элемент результата должен встречаться столько раз, сколько он отображается в обоих массивах, и вы можете вернуть результат в любом порядке .

Пример 1:
Ввод: nums1 = [1,2,2,1], nums2 = [2,2]
Выход: [2,2]

Пример 2:
Ввод: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Вывод: [4,9] или [9,4] 

Следовать за:
Что делать, если данный массив уже отсортирован? Как бы вы оптимизировали свой алгоритм?
Что делать, если nums1размер 's мал по сравнению с nums2размером '? Какой алгоритм лучше?
Что делать, если элементы nums2хранятся на диске, а память ограничена так, что вы не можете загрузить все элементы в память сразу?


Подход 1: HashMap

Использование HashMap для хранения вхождений элементов в nums1массиве.
Перебираем xмассив nums2, проверяем, cnt[x] > 0затем добавляем xк нашему ответу и уменьшаем cnt[x]на единицу.
Чтобы оптимизировать пространство, мы обеспечиваем len(nums1) <= len(nums2)замену nums1на nums2if len(nums1) > len(nums2).
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        if len(nums1) > len(nums2): return self.intersect(nums2, nums1)
            
        cnt = Counter(nums1)
        ans = []
        for x in nums2:
            if cnt[x] > 0:
                ans.append(x)
                cnt[x] -= 1
        return ans
Сложность:

Время: O(M + N), где M длина nums1 массива, N длина nums2.
ополнительное пространство: O(min(M, N))
✔️ Подход 2: Сортировка, затем два указателя

class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        
        ans = []
        i = j = 0
        while i < len(nums1) and j < len(nums2):
            if nums1[i] < nums2[j]:
                i += 1
            elif nums1[i] > nums2[j]:
                j += 1
            else:
                ans.append(nums1[i])
                i += 1
                j += 1
        return ans
Сложность:

Время: O(MlogM + NlogN), где M <= 1000длина nums1массива, N <= 1000длина nums2массива.
Дополнительное пространство: O(sorting)
✔️ Дополнительный вопрос 1. Что делать, если данный массив уже отсортирован? Как бы вы оптимизировали свой алгоритм?

Подход 2 — лучший выбор, поскольку мы опускаем стоимость сортировки.
Таким образом, временная сложность равна O(M+N), а пространственная сложность равна O(1).
✔️ Дополнительный вопрос 2. Что делать, если nums1размер 's мал по сравнению с nums2размером ' s? Какой алгоритм лучше?

Подход 1 — лучший выбор.
Временная сложность O(M+N), а пространственная сложность O(M), где Mдлина nums1, Nдлина nums2.
✔️ Дополнительный вопрос 3: Что делать, если элементы nums2хранятся на диске, а память ограничена так, что вы не можете загрузить все элементы в память сразу?

Если nums1умещается в памяти, мы можем использовать подход 1 , который сохраняет все элементы nums1в HashMap. Затем мы можем последовательно загружать и обрабатывать файлы nums2.
Если ни один nums1из них не nums2помещается в память, мы разбиваем числовой диапазон на числовые поддиапазоны, которые помещаются в память.
Мы модифицируем Подход 1 , чтобы подсчитывать только элементы, которые принадлежат заданному числовому поддиапазону.
Мы обрабатываем каждый числовой поддиапазон один за другим, пока мы обрабатываем все числовые поддиапазоны.
Например:
Входное ограничение:
1 <= nums1.length, nums2.length <= 10^10.
0 <= nums1[i], nums2[i] < 10^5
Наша память может хранить до 1000элементов.
Затем мы разбиваем числовой диапазон на числовые поддиапазоны [0...999], [1000...1999], ..., [99000...99999], затем вызываем Подход 1 для обработки 100 числовых поддиапазонов.